"Describes API authentication requirements."
directive @auth("which authenticated subjects have access"
subjectType: String, "which roles have access"
roles: [String]) on QUERY | MUTATION
"Marks a fragment as being optionally deferrable. Allowing the backend to split the query and return non-deferred parts first. This implicitly uses a streaming transport protocol which requires client support."
directive @defer(if: Boolean, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

schema {
  query: Queries
  mutation: Mutations
  subscription: Subscriptions
}
"Base64-encoded binary payload."
scalar BytesBase64
scalar Json
"""

An identifier established by the Client that MUST contain a String, Number,
or NULL value if included. If it is not included it is assumed to be a
notification. The value SHOULD NOT be NULL for requests expecting a response,
and Numbers SHOULD NOT contain fractional parts. The Server MUST reply with
the same value in the Response object if included. This member is used to
correlate the context between the two objects. A2A methods typically expect a
response or stream, so id will usually be present and non-null.
        
"""
scalar JsonRpcId
scalar Long
"A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system using the format 1970-01-01T00:00:00Z"
scalar OffsetDateTime

union ChatCompletionStreamChunk = ChatCompletionStreamError | ChatCompletionStreamResponseChunk

union JsonRpcResponseGQL = JsonRpcErrorResponseGQL | JsonRpcSuccessResponseGQL

"Alias for backward compatibility"
union JSONRPCResponse = JSONRPCErrorResponse | JSONRPCSuccessResponse

"Stream of document updates for a project"
union ReceiveEvent = ChangesAppliedEvent | NodeStatusUpdate | SnapshotEvent | StatusHistoryUpdate

"Item emitted by walletUpdates. The first event is the wallet state."
union WalletStreamEvent = BalanceChange | PriceChange | TransactionEvent | WalletStateEvent

"Indicates whether the behavior is managed within the platform or represents an external integration"
enum AgentBehaviorKind {
  A2ADeployment
  AionDeployment
  Distribution
  System
}

"Indicates whether the identity is for a user's personal agent or a deployed agent"
enum AgentIdentityType {
  Deployed
  Personal
}

"Distinguishes native coins from tokens"
enum AssetKind {
  Native
  Token
}

"Where the deployment source is hosted"
enum DeploymentType {
  A2ARemote
  AionRemote
  GitHubAionHosted
}

enum GitHubAccountType {
  Organization
  User
}

enum LogLevel {
  Debug
  Error
  Info
  Trace
  Warn
}

"Supported networks"
enum Network {
  ARBITRUM
  BASE
  BNB_CHAIN
  ETHEREUM
  OPTIMISM
  OTHER
  POLYGON
}

"Enumeration of supported user network types"
enum NetworkType {
  "Aion Network"
  Aion
  "A2A API Network"
  Api
  "Telegram Network"
  Telegram
}

"Severity level for a node status"
enum NodeStatusType {
  Error
  Info
  Success
  Warning
  Working
}

"Access level for a memory space"
enum Privacy {
  "Only the owner can access the memory space"
  Private
  "Memory space can be shared publicly"
  Public
}

"Category of a status history entry"
enum StatusHistoryType {
  Committed
  Error
  Info
  Success
  Warning
}

enum SubjectType {
  User
  Version
}

"Direction relative to wallet owner"
enum TransactionDirection {
  RECEIVED
  SENT
}

"Transaction status"
enum TransactionStatus {
  CONFIRMED
  PENDING
}

"Lifecycle status of a deployment version"
enum VersionStatus {
  Building
  Cancelled
  Error
  Offline
  Online
  Provisioning
  Queued
}

"JSON-RPC request envelope for agent-to-agent workflows"
input JsonRpcRequestGQLInput {
  "JSON-RPC protocol version, defaults to 2.0"
  jsonrpc: String!
  "Method invoked on the destination agent"
  method: String!
  "Parameters forwarded to the method call"
  params: Json
  "Identifier for correlating responses to the request"
  id: JsonRpcId
}

"Alias for backward compatibility"
input JSONRPCRequestInput {
  "JSON-RPC protocol version, defaults to 2.0"
  jsonrpc: String!
  "Method invoked on the destination agent"
  method: String!
  "Parameters forwarded to the method call"
  params: Json
  "Identifier for correlating responses to the request"
  id: JsonRpcId
}

input LogFiltersInput {
  startTime: OffsetDateTime!
  endTime: OffsetDateTime
  logLevels: [LogLevel!]!
  traceId: ID
  distributionId: ID
  versionId: ID
  agentEnvironmentId: ID
  messageSearch: String
}

input MessageInput {
  role: String!
  content: String!
}

"Configuration describing how an agent is deployed"
type AgentBehavior {
  "Unique identifier for the behavior"
  id: ID!
  "Identifier of the user that owns this behavior"
  userId: ID!
  "Associated deployment for this behavior"
  deploymentId: ID
  "Version of the deployment used by the behavior"
  versionId: ID
  "Lifecycle state of this behavior"
  kind: AgentBehaviorKind!
  "the semantic version defined for the behavior by the developer in the Aion.yaml config."
  logicalVersion: String!
  "the developer-assigned name of the behavior from the Aion.yaml or AgentCard. Set to the graphId if not found."
  name: String!
  "Optional developer-assigned name of the behavior from the Aion.yaml or AgentCard."
  description: String
  "Schema describing the configuration variables"
  configurationSchema: Json
  "Optional AgentCard manifest describing this behavior"
  agentCard: Json
  "LangGraph graph identifier if applicable"
  graphId: String
}

"Public profile information for a user or agent"
type AgentIdentity {
  "Unique identifier for the identity"
  id: ID!
  "Type of the agent identity (personal or deployed)"
  agentType: AgentIdentityType!
"""
Reference to the owning user account. Personal identities always map to
their user.
"""
  userId: ID
  "Reference to the associated organization"
  organizationId: ID
  "Identity name; personal identities should match the owning user's name"
  name: String
  "Agent-to-Agent protocol endpoint URL"
  a2aUrl: String
  "Website URL for human consumption"
  website: String
  "Primary contact email address"
  email: String
  "Addressable handle applicable inside the Aion network"
  atName: String
"""
Description of the identity's purpose; personal identities use the
user's bio
"""
  biography: String
  "URL to the identity's avatar image"
  avatarImageUrl: String
  "URL to the identity's profile background image"
  backgroundImageUrl: String
  "Internal notes for administrators"
  notes: String
}

"Blockchain asset, either native coin or token"
type Asset {
  id: ID!
  symbol: String!
  name: String
  iconUrls: TokenIconUrls
  address: String
  network: Network!
  decimals: Int!
  kind: AssetKind!
}

"Balance and price information for an asset"
type AssetBalance {
  "Asset metadata"
  asset: Asset!
  "Normalized balance already adjusted by asset.decimals"
  balance: Float!
}

"Current price information for an asset"
type AssetPrice {
  asset: Asset!
  value: Float!
  currency: String!
}

"Balance change update"
type BalanceChange {
  assetBalance: AssetBalance!
}

"Git branch available in a repository"
type BranchOption {
  "Branch name"
  name: String!
}

"Result of applying Automerge changes"
type ChangesApplied {
  "Project identifier"
  projectId: ID!
  "Concatenated set of raw Automerge changes which can be applied to an Automerge document via loadIncremental"
  incrementalChanges: BytesBase64!
  "New document heads after applying changes"
  newHeads: Heads!
}

"Applied changes event"
type ChangesAppliedEvent {
  "Changes payload"
  payload: ChangesApplied!
}

type ChatCompletionStreamChoice {
  index: Int!
  delta: Delta!
  finish_reason: String
}

type ChatCompletionStreamError {
  message: String!
}

type ChatCompletionStreamResponse {
  id: String!
  created: Long!
  model: String!
  choices: [ChatCompletionStreamChoice!]!
}

type ChatCompletionStreamResponseChunk {
  response: ChatCompletionStreamResponse!
}

type ClientSecret {
  clientId: ID!
  secret: String!
}

type ClientSecretHash {
  id: ID!
  clientId: ID!
  secretHash: String!
  subjectType: SubjectType!
  subjectId: ID!
}

"Details returned after provisioning a new remote deployment"
type CreateRemoteDeploymentResponse {
  "Deployment that was created"
  deployment: Deployment!
  "Default environment associated with the deployment"
  environment: DeploymentEnvironment!
  "Initial version of the deployment"
  version: Version!
  "Hash of the generated client secret"
  clientSecretHash: ClientSecretHash!
  "Plain-text client secret for the user"
  clientSecret: ClientSecret!
}

type Delta {
  role: String
  content: String
}

"Basic information about a deployment"
type Deployment {
  "Unique identifier of the deployment"
  id: ID!
  "Owning organisation if applicable"
  organizationId: ID
  "User that created the deployment"
  userId: ID
  "Project this deployment is associated with"
  projectId: ID!
  "Repository backing the deployment"
  repositoryId: ID
  "Human friendly name"
  name: String!
  "Type of deployment"
  deploymentType: DeploymentType!
  "Path within the repository containing source code"
  sourceRoot: String
  "Whether auto versioning is enabled"
  hasAutoVersionEnabled: Boolean!
}

"Detailed information about a deployment."
type DeploymentDetail {
  "Unique identifier for the deployment"
  id: ID!
  "Deployment configuration"
  deployment: Deployment!
  "Environments associated with the deployment"
  environments: [DeploymentEnvironment!]!
  "Versions that belong to this deployment"
  versions: [Version!]!
  "GitHub repository linked to this deployment, if any"
  repository: Repository
}

"Specific environment configuration for a deployment"
type DeploymentEnvironment {
  "Unique identifier of the environment"
  id: ID!
  "Deployment this environment belongs to"
  deploymentId: ID!
  "Project this environment is associated with"
  projectId: ID!
  "Environment name"
  name: String!
  "Git branch associated with the environment"
  branch: String
  "Environment variables applied to builds"
  environmentVariables: [KVStringString!]!
}

"Represents the state of GitHub repository selection."
type GitHubInstallationOptions {
  "True if the user has authorized via GitHub OAuth"
  hasGitHubOAuth: Boolean!
  "URL that the client can use to start GitHub OAuth authorization"
  gitHubOAuthUrl: String!
  "URL that the client can use to install the GitHub App"
  gitHubInstallationUrl: String!
  "Available GitHub App installations the user can choose from"
  installationOptions: [InstallationOption!]!
}

"Automerge heads (commit IDs)"
type Heads {
  "Base64-encoded head commit identifiers"
  values: [BytesBase64!]!
}

"Selectable GitHub App installation"
type InstallationOption {
  "Unique identifier of the installation option"
  gitHubInstallationId: Long!
  "Human readable name for the installation"
  name: String!
}

type JsonRpcError {
  code: Int!
  message: String!
  data: Json
}

type JsonRpcErrorResponseGQL {
  "Identifier correlating the response to its request"
  id: JsonRpcId
  error: JsonRpcError!
  jsonrpc: String!
}

type JsonRpcSuccessResponseGQL {
  "Identifier correlating the response to its request"
  id: JsonRpcId
  result: Json!
  jsonrpc: String!
}

"Alias for backward compatibility"
type JSONRPCSuccessResponse {
  "Identifier correlating the response to its request"
  id: JsonRpcId
  result: Json!
  jsonrpc: String!
}

"Alias for backward compatibility"
type JSONRPCErrorResponse {
  "Identifier correlating the response to its request"
  id: JsonRpcId
  error: JsonRpcError!
  jsonrpc: String!
}

"A key-value pair of String and String"
type KVStringString {
  "Key"
  key: String!
  "Value"
  value: String!
}

"A log event"
type LogEvent {
  level: String!
  level_value: Int!
  message: String!
  timestamp: OffsetDateTime!
  properties: [KVStringString!]!
}

"Structured memory store that agents can read and write"
type MemorySpace {
  "Unique identifier of the memory space"
  id: ID!
  "Display name for the space"
  name: String!
  "Optional description of the space's contents"
  description: String
  "Instructions that guide how the space should be used"
  instructions: String
  "Agent that owns the memory space"
  owner: AgentIdentity!
  "Privacy setting for the space"
  privacy: Privacy!
  "Agents that the space is shared with"
  sharedWith: [AgentIdentity!]!
}

type Mutations {
  "Creates a new agent identity for the authenticated user."
  createAgentIdentity(agentType: AgentIdentityType!, organizationId: ID, name: String, atName: String, biography: String, avatarImageUrl: String, backgroundImageUrl: String, a2aUrl: String, website: String, email: String, notes: String): AgentIdentity @auth(subjectType: "User")
  "Updates an existing agent identity owned by the authenticated user."
  updateAgentIdentity(agentIdentityId: ID!, name: String, atName: String, biography: String, avatarImageUrl: String, backgroundImageUrl: String, a2aUrl: String, website: String, email: String, notes: String): AgentIdentity @auth(subjectType: "User")
  "Deletes an agent identity owned by the authenticated user."
  deleteAgentIdentity(agentIdentityId: ID!): AgentIdentity @auth(subjectType: "User")
  "Registers a new Aion A2A server with the control plane. This should be called when the server first starts up. Returns all behaviors found in the configuration."
  registerVersion("Serialized agent manifest retrieved from the runtime. This payload is forwarded to populate agent behaviors and configuration metadata during registration." manifest: String!): [AgentBehavior!] @auth(subjectType: "Version")
  createRemoteDeployment(name: String!, serverUrl: String!, projectId: ID!, isA2AIntegration: Boolean!): CreateRemoteDeploymentResponse @auth(subjectType: "User")
  createGitHubDeployment(name: String!, sourceRoot: String, branchName: String, hasAutoVersionEnabled: Boolean!, gitHubInstallationId: Long!, githubRepoId: Long!, projectId: ID!): DeploymentDetail @auth(subjectType: "User")
  createOrUpdateDeploymentEnvironment(deploymentId: ID!, projectId: ID!, deploymentEnvironmentId: ID, branch: String, environmentalVariables: Json): DeploymentEnvironment @auth(subjectType: "User")
"""

        Apply raw Automerge changes to a project's document. Server applies and returns 
        committed heads and echoes changes. Validation and execution of side-effects are
        handled asynchronously and will not be completed in this request.

        If the server needs to modify the document in response to the changes, those updates
        will be returned via the receiveProjectChanges subscription.
      
"""
  applyProjectChanges("Identifier of the project being modified." projectId: ID!, "Base64-encoded Automerge change frames." changes: [BytesBase64!]!): ChangesApplied @auth(subjectType: "User")
  "Create empty project"
  createProject("Name of the project." projectName: String!, "Optional environment name for the project. Defaults to 'production'." environmentName: String): ProjectMetadata @auth(subjectType: "User")
  "Rename or update project environment"
  updateProjectMetadata("Identifier of the project to update." projectId: ID!, "New project name, if changing." projectName: String, "New environment name, if changing." environmentName: String): ProjectMetadata @auth(subjectType: "User")
  "Remove project and its history"
  deleteProject("Identifier of the project to remove." projectId: ID!): Boolean @auth(subjectType: "User")
}

"Status details for a node"
type NodeStatus {
  "Identifier of the node"
  nodeId: String!
  "Category of the status"
  nodeStatusType: NodeStatusType!
  "Human readable message"
  message: String!
  "Creation timestamp in milliseconds"
  createdAt: Long!
  "Last update timestamp in milliseconds"
  updatedAt: Long!
}

"Event containing node status updates"
type NodeStatusUpdate {
  "Status update payload"
  payload: NodeStatusUpdatePayload!
}

"Payload of node status updates"
type NodeStatusUpdatePayload {
  "Project identifier"
  projectId: ID!
  "Statuses for nodes"
  statuses: [NodeStatus!]!
}

"Price change update"
type PriceChange {
  assetPrice: AssetPrice!
}

"Basic information about a project"
type ProjectMetadata {
  "Unique project identifier"
  id: ID!
  "Name of the project"
  projectName: String!
  "Optional environment name"
  environmentName: String
}

type Queries {
  "Retrieves a user by ID. When no userId is supplied, returns the currently authenticated user."
  user(userId: ID): User
  memorySpaces: [MemorySpace!]
  "Retrieves a list of all agent identities available to the authenticated user."
  agentIdentities: [AgentIdentity!]
  agentIdentity(agentIdentityId: ID!): AgentIdentity @auth(subjectType: "User")
  "Retrieves a specific agent behavior by its ID for the authenticated user."
  agentBehavior(agentBehaviorId: ID!): AgentBehavior @auth(subjectType: "User")
  "Retrieves repositories available for import for the specified owner."
  gitHubRepositoryOptions(gitHubInstallationId: Long!): [RepositoryOption!] @auth(subjectType: "User")
  "Retrieves branches available for a repository."
  gitHubBranchOptions(gitHubInstallationId: Long!, gitHubRepoId: Long!): [BranchOption!] @auth(subjectType: "User")
  "Retrieves a list of deployments for a specific user."
  deployments: [Deployment!] @auth(subjectType: "User")
  "Retrieves a specific deployment by its ID for the authenticated user."
  deployment(deploymentId: ID!): DeploymentDetail @auth(subjectType: "User")
  "Entry point to get the wallet state"
  walletState(address: String!): WalletStateWithPrices
  "List of projects (no doc bytes)"
  projects: [ProjectMetadata!] @auth(subjectType: "User")
  "Retrieves JSON logs for a specific project ID with optional filters."
  projectLogs(projectId: ID!, filters: LogFiltersInput!): [LogEvent!] @auth(subjectType: "User")
  "Retrieves log trace records for a specific project ID with optional filters."
  logTraces(projectId: ID!, filters: LogFiltersInput!): [Trace!] @auth(subjectType: "User")
}

"GitHub repository managed by the platform"
type Repository {
  "Internal repository identifier"
  id: ID!
  "GitHub App installation that owns the repository"
  gitHubInstallationId: Long!
  "GitHub repository ID"
  githubRepoId: Long!
  "Owner ID on GitHub"
  gitHubOwnerId: Long!
  "Type of owner account"
  gitHubOwnerType: GitHubAccountType!
  "Repository name"
  name: String!
  "HTTPS clone URL"
  url: String!
}

"Repository available for import"
type RepositoryOption {
  "GitHub repository ID"
  githubRepoId: Long!
  "Repository name"
  name: String!
  "Repository description if available"
  description: String
  "If repository is private"
  isPrivate: Boolean!
}

"Automerge snapshot for a project"
type Snapshot {
  "Project identifier"
  projectId: ID!
  "Automerge document bytes"
  bytes: BytesBase64!
  "Heads corresponding to bytes"
  heads: Heads!
}

"Snapshot of project document"
type SnapshotEvent {
  "Snapshot payload"
  payload: Snapshot!
}

"Historical status change"
type StatusHistory {
  "Identifier of the history entry"
  id: ID!
  "Type of status change"
  statusHistoryType: StatusHistoryType!
  "Human readable message"
  message: String!
  "Creation timestamp in milliseconds"
  createdAt: Long!
  "Last update timestamp in milliseconds"
  updatedAt: Long!
}

"Event containing project status history"
type StatusHistoryUpdate {
  "Status history payload"
  payload: StatusHistoryUpdatePayload!
}

"Payload of status history updates"
type StatusHistoryUpdatePayload {
  "Project identifier"
  projectId: ID!
  "Recent status history entries"
  history: [StatusHistory!]!
}

type Subscriptions {
  "Executes an agent-to-agent JSON-RPC request and streams the responses."
  a2aRpc("JSON-RPC request body" request: JsonRpcRequestGQLInput!, "Distribution that should handle the request" distributionId: ID!): JsonRpcResponseGQL @auth(subjectType: "User")
  "Alias for backward compatibility - use a2aRpc instead"
  a2aStream("JSON-RPC request body" request: JSONRPCRequestInput!, "Distribution that should handle the request" distributionId: ID!): JSONRPCResponse @auth(subjectType: "User")
  "Streams delta chunks for an LLM chat-completion request. When `stream=true` is set, the underlying model returns partial responses; this subscription forwards those chunks to the client as they become available, enabling token-level streaming UIs."
  chatCompletionStream(model: String!, messages: [MessageInput!]!, stream: Boolean!): ChatCompletionStreamChunk @auth(subjectType: "Version")
  "Emits updates to GitHub installation options for the authenticated user. Useful for dashboards that must stay synchronized with the user's current GitHub access rights."
  gitHubInstallationOptions: GitHubInstallationOptions @auth(subjectType: "User")
  "Streams wallet state then incremental updates"
  walletUpdates(address: String!): WalletStreamEvent
  "Stream of document updates for a project"
  receiveProjectChanges("Identifier of the project to observe." projectId: ID!): ReceiveEvent @auth(subjectType: "User")
  "Streams JSON logs for a specific version ID"
  versionLogs(versionId: ID!, startTime: OffsetDateTime!): LogEvent @auth(subjectType: "User")
  "Streams JSON logs for a specific trace ID with optional filters."
  projectLogs(projectId: ID!, filters: LogFiltersInput!): LogEvent @auth(subjectType: "User")
}

"Token icon URLs in multiple sizes"
type TokenIconUrls {
  thumbnail: String
  small: String
  large: String
}

"A log trace record"
type Trace {
  traceId: ID!
  projectId: ID!
  distributionId: ID!
  versionId: ID!
  agentEnvironmentId: ID!
  lastMessage: String!
  lastTimestamp: OffsetDateTime!
  method: String
  taskStatus: String
}

"A transaction event involving a blockchain asset"
type Transaction {
  id: ID!
  timestamp: String!
  from: String!
  to: String!
  asset: Asset!
  value: Float!
  direction: TransactionDirection!
  status: TransactionStatus!
  blockExplorerUrl: String!
}

"Transaction update event"
type TransactionEvent {
  transaction: Transaction!
}

"Represents a user account"
type User {
  "Unique identifier of the user"
  id: ID!
  "Identifier of the user's personal agent identity"
  agentIdentityId: ID!
  "Identifier from the authentication provider"
  authId: String!
  "User's @ handle"
  atName: String
  "Display name"
  name: String
  "URL of the user's avatar image"
  avatarUrl: String
  "Networks linked to this user"
  networks: [UserConnection!]
}

"Association between a user and an external network"
type UserConnection {
  "Type of network linked to the user"
  network: NetworkType!
}

"A single build or release of a deployment"
type Version {
  "Unique identifier of the version"
  id: ID!
  "Deployment this version belongs to"
  deploymentId: ID!
  "Environment the version was built for"
  environmentId: ID
  "Git commit hash used for the build"
  commitHash: String
  "Commit message associated with the build"
  commitMessage: String
  "True if the version was manually triggered"
  isManual: Boolean!
  "Current status of the version"
  status: VersionStatus!
  "URL of the running server, if applicable"
  serverUrl: String
  "Client identifier that initiated the build"
  client_id: ID
}

"Full wallet state response"
type WalletState {
  address: String!
  assets: [AssetBalance!]!
  recentTransactions: [Transaction!]!
}

"Initial wallet state snapshot"
type WalletStateEvent {
  walletStateWithPrices: WalletStateWithPrices!
}

"Wallet state enriched with price information"
type WalletStateWithPrices {
  walletState: WalletState!
  totalUsdValue: Float!
  assetPrices: [AssetPrice!]!
}